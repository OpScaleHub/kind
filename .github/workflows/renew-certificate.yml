name: Renew Certificate

on:
  schedule:
    - cron: '0 7 * * 0'  # Runs weekly on Sundays at midnight
  workflow_dispatch: # Allows manual triggering of the workflow

jobs:
  renew-certificate:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Setup Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential

      - name: Install Certbot
        run: |
          sudo apt-get update
          sudo apt-get install -y certbot python3-certbot-dns-cloudflare

      - name: Set environment variables
        env:
          API_TOKEN: ${{ secrets.API_TOKEN }}
          DOMAIN: ${{ vars.DOMAIN }}
        run: |
          export DOMAIN="[ $DOMAIN ]"
          echo "dns_cloudflare_api_token = ${API_TOKEN}" > cloudflare.ini
          chmod 600 cloudflare.ini

      - name: Renew certificate and create Kubernetes secret file
        env:
          DOMAIN: ${{ vars.DOMAIN }}
        run: |
          WORK_DIR="/tmp/letsencrypt"
          mkdir -p $WORK_DIR
          echo "The DOMAIN variable is set to $DOMAIN"
          certbot certonly \
            --domains "$DOMAIN,*.$DOMAIN" \
            --register-unsafely-without-email --agree-tos \
            --dns-cloudflare --dns-cloudflare-credentials cloudflare.ini \
            --server https://acme-v02.api.letsencrypt.org/directory  \
            --config-dir $WORK_DIR --work-dir $WORK_DIR --logs-dir $WORK_DIR

          TLS_CRT=$(cat $WORK_DIR/live/"$DOMAIN"/fullchain.pem | base64 -w 0)
          TLS_KEY=$(cat $WORK_DIR/live/"$DOMAIN"/privkey.pem | base64 -w 0)

          cat <<EOF > wildcard-tls.yaml
          apiVersion: v1
          data:
            tls.crt: $TLS_CRT
            tls.key: $TLS_KEY
          kind: Secret
          metadata:
            name: wildcard-tls
          type: Opaque
          EOF

      - name: Install Node.js and @octokit/rest
        uses: actions/setup-node@v2
        with:
          node-version: '16.x'
      - run: npm install @octokit/rest

      - name: Get latest stable release
        id: get_latest_release
        uses: actions/github-script@v6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            const { Octokit } = require("@octokit/rest");
            const octokit = new Octokit({
              auth: process.env.GITHUB_TOKEN
            });

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            try {
              const latestRelease = await octokit.repos.getLatestRelease({
                owner,
                repo,
              });
              console.log(`Latest release: ${latestRelease.data.tag_name}`);
              return latestRelease.data.tag_name;
            } catch (error) {
              console.log("No releases found. Creating initial stable release.");
              // Create an initial release named "stable"
              const createReleaseResponse = await octokit.repos.createRelease({
                owner,
                repo,
                tag_name: 'stable',
                name: 'stable',
                body: 'Initial stable release',
                draft: false,
                prerelease: false
              });
              console.log(`Release created: ${createReleaseResponse.data.html_url}`);
              return 'stable'; // Return the newly created tag name
            }

      - name: Upload artifact to release
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.server_url }}/${{ github.repository }}/releases/tag/${{ steps.get_latest_release.outputs }}
          asset_path: wildcard-tls.yaml
          asset_name: wildcard-tls.yaml
          asset_content_type: application/x-yaml
          overwrite: true